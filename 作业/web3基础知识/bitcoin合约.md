# Bitcoin 合约知识学习引导：从基础到实践
这篇来自 Bitcoin 官方 wiki 的文章是理解 Bitcoin 合约体系的核心资料，涵盖了合约的本质、核心技术原理和 8 个典型应用场景。下面我会按照“基础认知→核心技术→场景实践→关键注意事项”的逻辑，带你逐步拆解学习内容，帮你建立系统的知识框架。


## 一、先搞懂：Bitcoin 合约到底是什么？（基础认知）
在开始复杂技术前，先明确核心定义，避免和以太坊等“智能合约”混淆：
- **本质**：不是“自动执行的代码”，而是利用 Bitcoin 区块链和脚本系统，构建“最小信任”的协议，解决协作中的信任问题（比如交易担保、资金托管）。
- **核心价值**：没有让“不可能的事变可能”，而是通过技术手段减少对第三方的依赖，把人为判断从流程中移除，实现自动化协作（比如无需信任中介的 escrow 托管）。
- **延伸产物**：基于合约思想，能衍生出四类新工具（文章开篇重点提及，先有概念印象即可）：
    1. 智能财产（Smart Property）：可通过区块链原子化交易、借贷的资产；
    2. 可转移虚拟财产：不可复制、仅可交易的数字物品；
    3. 自治代理（Agents）：自带钱包、能自动买卖服务的程序；
    4. 分布式市场：实现点对点债券、股票交易，让 Bitcoin 向金融系统延伸。


## 二、必学：支撑 Bitcoin 合约的 3 个核心技术（原理层）
这部分是理解所有场景的基础，文章“Theory”章节详细讲解了 3 个关键技术，必须逐个吃透：

### 1. 交易的“时间锁”（Lock Time）：控制交易生效时间
- **作用**：让交易在“特定时间/区块高度前”处于“待生效”状态，只有满足条件后才会被区块链确认。
- **规则**：
    - 字段值 < 5 亿：表示“区块高度”（比如设为 100000，意为第 10 万个区块产生后才生效）；
    - 字段值 ≥ 5 亿：表示“时间戳”（比如设为 1717248000，意为 2024 年 6 月 1 日后才生效）；
    - 特殊情况：如果交易所有输入的“序列号（Sequence Number）”都是 `UINT_MAX`（最大值），即使设了 Lock Time，交易也会被视为“立即生效”。

- **为什么重要**：合约的“条件触发”（比如“6 个月后返还押金”）全靠它实现，是时间相关合约的基础。


### 2. 序列号（Sequence Number）：实现交易可修改
- **默认状态**：普通转账交易中，序列号都是 `UINT_MAX`，配合 Lock Time=0，意味着交易“不可修改、立即生效”；
- **合约核心用法**：将序列号设为非最大值（比如 0），此时即使 Lock Time 未到，交易也可被“修改并重签”——比如双方约定“6 个月后返还押金”，但中途想提前解约，只需将序列号+1，重新设置 Lock Time=0，双方重签后即可生效。

- **关键逻辑**：每个输入的序列号独立，适合“多参与方合约”（比如 3 人共管资金，每人可独立修改自己输入的序列号，无需其他人同步操作）。


### 3. SIGHASH 标志：控制签名的“范围”（最灵活的技术）
签名是 Bitcoin 交易的核心，但合约需要“部分签名”（比如 A 签交易的“输入”，B 签“输出”），SIGHASH 标志就是实现这一需求的关键，它分“模式”和“ANYONECANPAY 修饰符”两类：

#### （1）3 种基础模式：控制“签名覆盖交易的哪些部分”
| 模式          | 作用（用通俗语言解释）                                  | 典型场景                  |
|---------------|---------------------------------------------------------|---------------------------|
| SIGHASH_ALL   | 默认模式，签名覆盖“除输入脚本外的所有部分”（输入属性、输出全签） | 双方固定金额的交易（比如 A 转 1 BTC 给 B，B 确认后 A 签名，输出不可改） |
| SIGHASH_NONE  | 不签“输出”，只签“输入”（输出可任意修改）                | 多人集资，输出由最后一人确定（比如 A、B 各出 0.5 BTC，C 决定最终转给谁） |
| SIGHASH_SINGLE| 只签“与当前输入位置对应的输出”（其他输出可改）          | 多输出交易中，只关心自己的收益（比如 A 参与交易，只确保自己的 0.3 BTC 输出正确，其他人的输出不管） |

#### （2）ANYONECANPAY 修饰符：允许“添加新输入”
- 作用：和上述 3 种模式结合后，签名只覆盖“当前输入”，其他人可随意添加新的输入（比如 A 签了 0.2 BTC 的输入，B 可再添加 0.3 BTC 的输入，A 的签名依然有效）；
- 核心场景：众筹类合约（比如文章“Example 3 担保合约”，多人分别签名自己的出资，最后合并成一个总交易）。


### 补充：CHECKMULTISIG  opcode（多签）
虽然属于脚本系统，但几乎所有合约都依赖它实现“多参与方控制”：
- 功能：实现“n-of-m 多签”（比如 2-of-3：提供 3 个公钥，需要其中 2 个签名才能花掉资金）；
- 示例脚本：`2 <pubkey1> <pubkey2> <pubkey3> 3 CHECKMULTISIGVERIFY`（3 个公钥，需 2 个签名）；
- 为什么关键：合约的“共同控制”（比如 escrow 托管需要买家+卖家+中介中 2 人签名）全靠它实现。


## 三、实践落地：8 个典型合约场景（重点学前 4 个）
文章用 8 个例子讲解合约的实际应用，建议先重点掌握前 4 个（覆盖“押金、托管、众筹、外部状态交互”，最常用且能串联核心技术）：

### 场景 1：押金担保（Example 1）—— 用 Lock Time 实现“到期自动返还”
- **问题**：用户在网站注册，想证明自己不是垃圾账号（交押金），但担心网站卷款跑路，或自己注销账号后押金不返还；
- **合约流程**（核心是“双交易+多签+Lock Time”）：
    1. 用户和网站交换公钥；
    2. 用户创建 Tx1（多签交易）：把 10 BTC 转入“需双方签名才能花”的输出（不广播），并把 Tx1 的哈希发给网站；
    3. 网站创建 Tx2（合约交易）：花掉 Tx1 的资金，将 10 BTC 返还给用户，设置 Lock Time=6 个月（6 个月后自动生效），序列号设为 0（可修改），只签自己的部分，发给用户；
    4. 用户验证 Tx2 无误后，补签自己的签名，先广播 Tx1（锁定资金），再广播 Tx2（锁定返还规则）；
- **灵活调整**：
    - 提前注销账号：网站修改 Tx2 的 Lock Time=0、序列号=UINT_MAX，双方重签后广播，提前返还押金；
    - 延长账号：双方重签 Tx2，将 Lock Time 设为更晚时间，序列号+1 后广播。


### 场景 2：托管与纠纷调解（Example 2）—— 用 CHECKMULTISIG 实现“三方控制”
- **问题**：买家和陌生卖家交易，想确保“付款后能收到货”，卖家想确保“发货后能收到钱”，需要第三方中介调解纠纷；
- **核心设计**：2-of-3 多签（买家 K3、卖家 K1、中介 K2，需任意 2 人签名才能花资金）；
- **交易流程**：
    1. 买家创建 Tx1，输出脚本为 `2 <K1> <K2> <K3> 3 CHECKMULTISIGVERIFY`，广播后锁定资金；
    2. 正常交易：买家确认收货后，和卖家共同签名 Tx1 的支出交易，资金转给卖家；
    3. 纠纷处理：
        - 买家没收到货：买家+中介签名，资金退回买家；
        - 卖家已发货但买家拒付：卖家+中介签名，资金转给卖家。


### 场景 3：担保合约（Example 3）—— 用 SIGHASH_ALL+ANYONECANPAY 实现“众筹达标才付款”
- **问题**：筹集资金做公益（比如建灯塔），想实现“总金额达标则付款给发起人，不达标则所有人不花钱”；
- **关键技术**：SIGHASH_ALL+ANYONECANPAY（允许多人添加输入，且输出不可改）；
- **流程**：
    1. 发起人宣布“筹集 1000 BTC 才启动”，并提供收款地址；
    2. 每个参与者创建“部分交易”：
        - 输入：自己的 BTC；
        - 输出：1000 BTC 到发起人地址（此时输入金额 < 输出金额，交易无效，防止发起人提前挪用）；
        - 签名：用 SIGHASH_ALL+ANYONECANPAY（只签自己的输入，允许其他人加输入，且输出不能改）；
    3. 参与者将“部分交易”发给发起人，发起人统计总金额；
    4. 总金额≥1000 BTC 时，发起人合并所有“部分交易”的输入，生成完整交易（输入总和≥1000 BTC，交易生效），广播后资金转给发起人；
- **安全点**：未达标的“部分交易”因输入<输出，无法广播，参与者无需担心资金被挪用。


### 场景 4：外部状态交互（Example 4）—— 用“预言机（Oracle）”连接区块链与现实世界
- **核心痛点**：Bitcoin 脚本是“纯函数”（不能访问外部数据，比如“某人是否去世”“汇率多少”），但合约常需要现实世界的状态（比如“祖父去世后给孙子遗产”）；
- **解决方案：预言机（Oracle）**：
    - 定义：拥有公钥的服务器，当“用户提供的条件成立”时，会对交易签名，让区块链上的合约生效；
- **示例：祖父给孙子遗产（两种触发条件：孙子 18 岁 OR 祖父去世）**：
    1. 处理“18 岁”条件：祖父创建交易 TxA，Lock Time=孙子 18 岁的时间戳，输出给孙子，签名后交给孙子（不广播），时间到后孙子广播即可；
    2. 处理“祖父去世”条件：
        - 祖父创建交易 TxB，输出脚本为 `<哈希> OP_DROP 2 <儿子公钥> <预言机公钥> CHECKMULTISIG`（哈希是“祖父去世”条件的哈希，比如 `has_died('john smith', 1950/01/02)`）；
        - 祖父将 TxB 交给孙子，同时告知预言机名称和条件表达式；
        - 祖父去世后，孙子向预言机提交“条件表达式+TxB+自己的签名”；
        - 预言机验证：表达式哈希是否匹配脚本、条件是否成立（比如查死亡记录），成立则签名 TxB；
        - 孙子补全预言机签名，广播 TxB 获得遗产。
- **信任优化**：为减少对单一预言机的依赖，可采用“多预言机（n-of-m）”“可信硬件”“AWS 可信环境”等方案（文章后续详细讲解，可作为延伸学习）。

## 一、场景5：跨链交易（Trading across chains）—— 实现不同区块链资产的“原子交换”
### 核心问题
Bitcoin、NameCoin（域名区块链）、EURcoins（锚定欧元的稳定币）等不同区块链资产，如何在“无中心化交易所”的情况下安全交易？避免“一方转账后另一方违约”的风险（即“双花”或“单边违约”）。

### 关键技术：TierNolan协议（原子交换核心）
核心思路是用“共享秘密+时间锁”确保两笔跨链交易“要么同时生效，要么都不生效”，以Bitcoin与EURcoins的跨链兑换为例，流程如下：
1. **准备阶段（链A：Bitcoin侧）**
    - 买家A生成随机秘密`x`，并计算其哈希`hash(x)`；
    - A创建交易`Tx1`（Bitcoin链）：输出脚本设置为“两种解锁方式”——① A和卖家B的双签名；② B的签名+秘密`x`（需验证`hash(x)`匹配），**不广播**；
    - A再创建交易`Tx2`（Bitcoin链）：作为`Tx1`的“退款合约”，将`Tx1`的资金退回A自己，设置**远期时间锁**（比如24小时后生效），序列号设为0（可修改），A签名后发给B，B补签后返回（确保B无法单独挪用`Tx1`资金）；
    - A广播`Tx1`和`Tx2`，Bitcoin链上的资金进入“锁定状态”。

2. **镜像阶段（链B：EURcoins侧）**
    - 卖家B在EURcoins链上执行完全对称操作：创建`Tx3`（EURcoins链），输出脚本同样支持“双签名”或“B的签名+秘密`x`”，并创建`Tx4`（B的退款合约），设置**比`Tx2`更短的时间锁**（比如12小时，关键设计：确保B的退款比A更早生效，倒逼A及时完成交易）；
    - B广播`Tx3`和`Tx4`，EURcoins链上的资金也进入锁定状态。

3. **完成交换（秘密泄露+交易确认）**
    - A在EURcoins链上，用“自己的签名+秘密`x`”解锁`Tx3`，将EURcoins转入自己账户——此操作会在EURcoins链上公开`x`；
    - B看到公开的`x`后，在Bitcoin链上用“自己的签名+`x`”解锁`Tx1`，将Bitcoin转入自己账户；
    - 若任一环节中断（比如A不解锁`Tx3`），B可在12小时后通过`Tx4`拿回EURcoins，A可在24小时后通过`Tx2`拿回Bitcoin，**无任何一方损失**。

### 技术亮点
- 无需中心化交易所，纯点对点完成跨链资产交换；
- 依赖“时间锁优先级”和“秘密共享”实现原子性，避免单边违约；
- 延伸方案：Sergio Demian-Lerner提出的`P2PTradeX`，通过将一条链的验证规则编码到另一条链，进一步优化跨链兼容性。


## 二、场景6：付费证明合约（Pay-for-proof contracts）—— 零信任购买“纯函数解决方案”
### 核心问题
如何为“计算结果”付费？比如购买“大数分解答案”“哈希碰撞解”，但担心：① 卖家提供错误结果；② 买家拿到结果后不付款（即“白嫖”计算成果）。

### 关键技术：零知识 contingent 支付（Zero Knowledge Contingent Payment）
核心是用“零知识证明（ZKP）”确保“只有当卖家提供正确结果时，买家的付款才会生效”，全程无需信任第三方，仅依赖密码学验证：
1. **定义“纯函数”任务**  
   任务必须是“纯函数”（输入固定则输出唯一，无副作用，比如“计算SHA-256(abc)的结果”“分解123456789为两个质数乘积”）——因为纯函数的结果可通过数学验证，无需依赖外部数据。

2. **创建条件支付合约**
    - 买家创建交易`Tx`：输出资金给卖家，但解锁条件是“卖家提供能通过零知识证明的正确结果”；
    - 零知识证明的作用：卖家无需公开完整计算过程，只需证明“我知道正确结果”（比如证明“我知道x，使得hash(x)=目标值”），买家通过验证证明即可确认结果正确。

3. **完成支付与验证**
    - 卖家向买家发送“结果+零知识证明”；
    - 买家验证证明通过后，交易`Tx`自动解锁，资金转入卖家账户；若证明失败，`Tx`无法解锁，买家资金可退回。

### 应用价值
- 为“计算服务”提供零信任支付方案，比如AI模型推理结果付费、密码学难题求解；
- 弥补了Bitcoin脚本“无法执行复杂计算”的缺陷——通过链下零知识证明+链上条件支付，实现“计算结果即服务”。


## 三、场景7：动态调整（微）支付（Rapidly-adjusted (micro)payments）—— 低成本高频支付优化
### 核心问题
Bitcoin基础交易需上链确认，每笔有矿工费且耗时（约10分钟），无法满足“高频微支付”场景（比如WiFi热点按流量付费：0.001 BTC/10KB，每几秒产生一笔交易）——成本高、效率低。

### 关键技术：支付通道（Payment Channel，闪电网络前身）
核心思路是“链下高频调整，链上最终结算”，用“多签锁定+可修改交易”减少上链次数，流程以“用户（客户端）向WiFi热点（服务器）付费”为例：
1. **创建链上“资金池”**
    - 用户生成公钥`K1`，向热点获取公钥`K2`；
    - 用户创建交易`T1`（上链）：将10 BTC转入“`K1`和`K2`双签”的输出（锁定资金，作为支付池），广播后确认；
    - 用户创建退款交易`T2`：将`T1`的资金全部退回自己，设置**远期时间锁**（比如24小时后生效），发给热点，热点签名后返回（确保热点无法单独挪用资金）。

2. **链下动态调整支付金额**
    - 用户创建交易`T3`：同样基于`T1`的输出，分为两个子输出——“用户剩余资金”和“热点已赚资金”，初始时“热点已赚资金=0”（等同于退款），用户签名后发给热点；
    - 当用户使用10KB流量时，修改`T3`：将“热点已赚资金”调整为0.001 BTC，“用户剩余资金”调整为9.999 BTC，重新签名后发给热点；
    - 热点验证金额无误后，保存最新版`T3`——后续每产生新消费，重复“修改金额+重签”，全程**不上链**。

3. **最终结算（上链）**
    - 当用户停止使用（或时间锁临近），热点签名最新版`T3`并广播，链上确认后，“热点已赚资金”转入热点账户，“用户剩余资金”转回用户账户；
    - 若热点失联，用户可在时间锁到期后广播`T2`，拿回全部未消费资金，避免损失。

### 技术亮点
- 高频微支付成本近乎为0（仅最终结算上链，花1笔矿工费）；
- 依赖“序列号可修改”和“时间锁”确保安全性：用户无法篡改已确认的支付金额，热点无法挪用未消费资金；
- 延伸：该方案是**闪电网络（Lightning Network）** 的核心原型，目前已成为Bitcoin高频支付的主流解决方案。


## 四、场景8：多方去中心化彩票（Multi-party decentralised lotteries）—— 无运营商的公平彩票
### 核心问题
传统彩票依赖运营商，存在“暗箱操作”风险（比如篡改中奖号码、截留奖金）；如何用Bitcoin合约实现“无运营商、全透明、公平不可篡改”的彩票？

### 关键技术：安全多方计算（Secure Multi-party Computation, SMPC）
核心思路是“多参与者共同生成中奖号码，且无人能单独控制结果”，流程简化如下（详细协议见论文《Secure multiparty computations on Bitcoin》）：
1. **参与报名（锁定资金）**
    - 每个参与者创建交易，将“彩票本金”转入“多签合约地址”（需所有参与者签名才能解锁奖金），同时生成一个“随机数+其哈希”，将哈希上链（隐藏真实随机数，防止他人模仿）。

2. **共同生成中奖号码**
    - 报名结束后，所有参与者公开自己的“真实随机数”，并验证“随机数的哈希是否与上链哈希匹配”（确保未篡改）；
    - 将所有真实随机数通过数学算法（比如异或）合并，生成“最终中奖号码”——因随机数由多人共同提供，无人能单独控制结果，确保公平。

3. **奖金分配（自动执行）**
    - 合约脚本验证“中奖号码是否匹配参与者的彩票号码”，确定中奖者；
    - 所有参与者签名“奖金分配交易”，将奖金转入中奖者账户（若无人中奖，本金按比例退回各参与者），全程上链，透明可查。

### 应用价值
- 实现“完全去中心化”的公平博弈：无任何中心化主体，规则由代码和数学保证，结果不可篡改；
- 拓展Bitcoin合约的“协作场景”：除彩票外，还可用于去中心化抽奖、竞拍等需要公平随机结果的场景。


## 总结：8个场景的技术逻辑串联
这8个场景本质是“核心技术（时间锁、SIGHASH、多签、预言机）”的组合应用，覆盖了从“单一链内协作”到“跨链交互”、从“低频大额”到“高频微支付”、从“简单资金托管”到“复杂多方计算”的全场景，可总结为以下逻辑：
| 技术核心                | 覆盖场景                | 解决的核心需求                |
|-------------------------|-------------------------|-----------------------------|
| 时间锁+多签             | 押金担保、托管调解      | 双方/三方协作的资金安全锁定    |
| SIGHASH_ALL+ANYONECANPAY| 担保合约（众筹）        | 多人集资，达标才付款          |
| 预言机+多签             | 外部状态交互（遗产）    | 区块链与现实世界状态打通      |
| 秘密共享+跨链时间锁     | 跨链交易                | 不同区块链资产的原子交换      |
| 零知识证明+条件支付     | 付费证明合约            | 零信任的计算结果付费          |
| 支付通道（多签+可修改交易）| 动态微支付            | 高频低成本支付                |
| 安全多方计算+多签       | 去中心化彩票            | 无运营商的公平协作            |

通过这8个场景，可完整理解Bitcoin合约的核心能力：**不依赖中心化主体，仅通过密码学和脚本规则，解决各类协作中的信任问题**，为后续学习更复杂的Bitcoin生态应用（如闪电网络、侧链）打下基础。


## 必须注意的“坑”：内存池交易替换机制（文章开头的警告）
这是实践中容易踩的雷，文章开篇专门提醒：
- **历史**：2010 年之前，可通过 `nSequence` 字段实现“内存池中的交易替换”（比如用新交易覆盖旧交易），但因存在 DoS 攻击风险，该机制被禁用，后续代码也被删除；
- **对合约的影响**：设计合约时，**不能依赖“交易替换”功能**（比如早期用“序列号修改+交易替换”实现的动态调整金额），否则合约在当前 Bitcoin 节点上无法运行；
- **未来**：若后续 Bitcoin 重新支持该机制，wiki 会更新，但目前需完全规避。