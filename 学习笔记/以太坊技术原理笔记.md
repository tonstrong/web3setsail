### 架构图

![image-20250728104002243](C:\Users\yt163\AppData\Roaming\Typora\typora-user-images\image-20250728104002243.png)



### 数据层

![image-20250728152603393](C:\Users\yt163\AppData\Roaming\Typora\typora-user-images\image-20250728152603393.png)

#### 1.数据库

使用LevelDB数据库，以键值对存储数据。并采用 Merkle Patricia Tree（MPT）作为数据结构来组织和管理。每个区块构成区块链的基本单位，包含了一系列交易列表。这些交易的执行将改变账户状态，从而更新以太坊的全局状态。



#### 2.账户数据结构

**账户模型：**以太坊使用的是区别于BTC的UTXO模型，而是一种传统的账户余额模型。

**账户类型：**分为外部账户和合约账户。

外部账户：由用户创建的账户，用户可以通过外部账户发起交易。(此处的交易不仅是价值转移，也可以触发合约账户执行代码，实现代币转移、状态修改、逻辑运算、新建合约账户、调用其他合约等功能)

合约账户：无法由用户直接操作，只能通过合约代码控制。可以通过外部账户直接调用或者其他合约代码调用。合约账户之间进行的消息通信，不会被序列化记录到区块链中。

仍和交易都是由外部账户触发，根据具体情况是否触发合约账户交易。

**账户状态**：外部账户和合约账户均由四个主要字段构成，分别是nonce、balance、storageRoot、codeHash。但是具体含义会有不同。

nonce：在外部账户中表示该账户总共发出交易的数量，用于防止重复交易。合约账户中则表示该账户创建合约的数量。

balance：账户余额，单位wei，1 ETH = 10^18wei。

storageRoot：一个指向Merkle Patricia Tree根节点的Hash，该树中存储了账户的状态信息。

codeHash：外部账户中，通常是空字符串哈希值。在合约账户中，代表了EVM代码(编译后的合约字节码)的哈希，该字段通常不可变，用作从EVM数据库检索相应的EVM代码的索引。

**账户生成**：

外部账户：通过一对公私钥生成。公钥作为账户地址；私钥存储在一个加密的json文件中，访问私钥需要通过设置的密码访问。所以验证账户时必须同时拥有私钥和密码。这些钥匙文件存放在以太坊节点的 `data/keystore` 目录下。在同一个节点的 `data/` 目录下的所有账户构成一个钱包，而一个以太坊节点可以通过设置不同的 `data/` 目录来创建和管理多个钱包。

合约账户：通过智能合约创建。只由合约部署者控制。



#### 3.交易原理

**交易定义：**以太坊中交易本质上是一个被签名的数据包，其中可以包含从一个账户到另一个账户的转账，也可以包含调用合约方法或部署新的合约。

**交易创建：**创建交易时需要包含以下信息

* nonce：该账户发生的交易总数。
* GasPrice：发送者愿意为每单位Gas支付的价格。
* GasLimit：发送者设定的本次交易最大消耗的Gas数。
* to：接收者地址。在创建合约的交易中，该字段为空，采用默认零地址。
* value：以wei为单位，从发送者向接收者转移的金额，或者是创建合约时赋予合约的初始金额。
* v,r,s：交易的签名组件，用于验证交易的发送者。
* init：仅用于合约创建的交易中，用于初始化新合约账户EVM代码片段。init代码在首次执行时返回一个永久与合约账户关联的代码提，执行完成后，init值被弃用。
* data：包含任意大小的字节数组，用于交易的附加信息，或者包含合约代码及其参数。

**交易签署**：由EIP-155规定的签名方案，即在交易数据中添加v,r,s三个字段。r,s初始值为0，v为链标识符。这三个字段被添加到交易序列号之前，会影响交易的hash值。由于存在链标识符，可以防止交易在不同链上被重放。

可用的链标识符如下表：

| 区块链名称        | 链标识符 |
| ----------------- | -------- |
| ETH 主网          | 1        |
| Expanse           | 2        |
| Rposten           | 3        |
| Rinkeby           | 4        |
| Rootstock 主网    | 30       |
| Rootstock 测试    | 31       |
| Kovan             | 42       |
| ETC 主网          | 61       |
| ETC 测试          | 62       |
| Geth private 测试 | 1337     |

**交易广播：**通过P2P网络，将信息在网络中广泛传播和确认。

**交易提交**：节点收到一个交易请求后，会将该交易存放到交易内存池中。交易内存池包含两个主要列表：queue列表和pending列表。请求首先被放入queue列表，在经过一定条件筛选后，如gas和nonce等，被转移到pending列表，等待进一步处理和确认。

**交易执行：**矿工从pending列表中选取交易后，交由EVM执行，并打包放到区块中。矿工不会等待执行结果，这一过程能加快整个区块执行速度。

**交易存储：**交易执行后，会生成一个收据，记录了交易对账户状态所做的改变。这个收据只有等交易所在的区块被正式添加到区块链上后，才会被提交存储到底层数据库。



#### 4.区块数据结构

与比特币相同，在以太坊中，区块也是交易的载体。打包区块的过程涉及到不断寻找一个小于系统指定哈希值的数字，以获得记账权。然而，与比特币的结构不同的是，以太坊的区块由**交易列表**和**叔区块**组成。

**叔区块：**由于以太坊的区块产生速度较快，同时由于网络延迟，首先完成区块打包的节点并不总是第一个将区块广播到网络的。因此，可能会出现同一时刻有多个矿工成功打包区块的情况，导致链的分叉。在发生分叉时，系统会选择所有分叉链中**总难度最高**的链作为**主链**，主链上的区块将获得挖矿奖励，其余区块会成为孤块，以太坊不同于比特币，不直接丢弃这些孤块，而是将符合条件的孤块纳入“uncle block”，允许它们作为主链区块的“叔块”被引用。要成为数块，必须满足以太坊规定，满足：

- 是前7代内的兄弟分支区块（即距当前主链高度不超过6的并行分支）
- 未被其他主链区块引用过

同时作为块同样可获得奖励，奖励情况大致如下（以ETH为例）：

- 被引用的uncle block矿工：可获得其本应获得全额区块奖励的7/8 ~ 0（根据与主链高度差递减）。
- 引用叔块的主链区块矿工：每引用一个uncle块，可获得1/32的完整区块奖励。

uncle节点的作用主要是提高以太坊网络的安全性、去中心化程度和矿工公平性，同时减少资源浪费，使因为网络延迟而未进入主链的区块依然获得奖励，有助于整个生态健康发展。



**区块结构：**![image-20250728135133927](C:\Users\yt163\AppData\Roaming\Typora\typora-user-images\image-20250728135133927.png)

**区块头**（注意：ommer 和 uncle 为同义词）：

parentHash：前一个区块的256位哈希值。

ommersHash：与该区块关联的区块的256位uncle哈希值。

beneficiary：接受交易费的矿工的以太坊地址。

stateRoot：在区块中所有交易执行完成且被确认后，状态树根节点的256位哈希值。

receiptsRoot：区块中所有交易收据组成的树的根节点256位哈希值。

transactionRoot：区块中所有交易组成的树的根节点256位哈希值。

logsBloom：区块中所有交易收据的日志所组成的Bloom过滤器。

difficulty：区块的难度值，根据父区块的难度值和时间戳计算得到。

number：区块的高度，创世区块为0。

gasLimit：区块中可用的最大Gas量。

gasUsed：区块中所有交易消耗的gas总量。

timestamp：区块生成的时间戳。

extraData：区块的附加数据，最长32字节。

mixHash：一个256位哈希，与nonce共同用于证明当前区块执行了足够的计算量。

nonce：工作量证明过程中生成的一个64位哈希值，与mixHash一起用于证明当前区块的计算量。

**区块体**

包含交易列表和引用的uncle区块列表。



**区块生成**

区块是由矿工根据一系列的特定规则从交易池中选择经过验证的交易打包，同时生成区块头和区块体。

在这个过程中，矿工扮演了接受、转发、验证和打包的关键角色。在eth1.0，网络采用的是POW算法来竞争记账权，竞争过程也被称为封印(seal)。

**区块封印**

挖矿过程分为两阶段：创建和封印。创建是矿工先创建出一个完整的新区块，包括区块头的部分属性、编排交易列表、添加unlce区块等。此时所有交易已经执行，所有交易的收据已经收集，且相关账户状态也已更新。接下来，只需等待第二阶段的封印结果，才能完成区块头中剩余部分属性的填充，如难度（Difficulty）、随机数（Nonce）和混合哈希（MixHash）等。

一旦封印完成，区块便可以被广播到其他节点。需要注意的是，封印阶段所消耗的计算资源远超过区块创建阶段。区块的封印是通过共识算法来完成的。目前，以太坊使用的共识算法包括 Ethash（以太坊主网采用）和 Clique（测试网如 ganache 采用）。在以太坊发展的第四阶段，系统将从工作量证明（PoW）转向权益证明（PoS），即采用基于 PoW 的 Casper 算法。封印过程不会改变区块中任何与有效数据相关的部分，其主要目的是通过一系列复杂的步骤来选拔具备本轮记账资格的矿工。POW大致流程如下：

flowchart TD
    A[收到新交易] --> B[放入交易池]
    B --> C[选取交易]
    C --> D[执行并验证交易]
    D --> E[打包成区块候选]
    E --> F[PoW运算: 不断尝试nonce]
    F --> G{哈希<难度?}
    G -- 是 --> H[广播新区块]
    G -- 否 --> F
    H --> I[全网验证]
    I --> J[写入主链 or 形成分叉]

**区块验证**

当一个区块被打包上链之后，其他收到该广播的节点需要进行验证。验证主要有以下步骤：

1.验证区块头和uncle区块：检查区块头的完整性和正确性，并检查uncle区块是否合规。

2.验证交易：确保区块中包含的交易都是有效的，包括交易的结构、签名。

3.发放奖励：验证矿工和相关参与者(如uncle区块的矿工)的奖励分配是否正确。

4.验证全局状态和工作量：检查区块的状态变化与执行结果是否一致，以及工作量是否有效。

**选择主链**

在以太坊中，新区块在某个节点通过验证后，还需确认该区块所在的链是否为主链。鉴于以太坊中区块的生成速度较快，常常同时产生多个区块，形成一种区块树的结构。在这种情况下，主链定义为这棵区块树中**从根节点到叶子节点最长路径上的链**。

为了达成网络的共识，通常**选择总难度最大的**路径作为主链。主链的识别最直观的方法是比较从根节点到叶子节点的路径长度，即非创世区块的数量。路径越长，意味着该路径上累计的挖矿工作量越大。

在路径长度相等的情况下，需要比较两个叶子节点路径上**区块的总难度**。每个新区块的总难度由该区块自身的难度值加上其父区块的难度值组成。由于区块头包含了难度值信息，因此可以仅通过区块头来比较各个路径已完成的计算量。

**存储区块**

在新区块确认加入主链后，区块中的数据才会被以键值对形式存入节点本地的LevelDB中。存入过程：

1. handleNumberToKey(HeightNumber) -> BlockHash；（区块高度和hash的映射）
2. handleNumberAndHashToHeaderKey(HeightNumber, hash) -> Header{各种hash，difficulty，Nonce，mixDigest，Number，GasUsed，GasLimit} （区块高度和区块hash组成的key和 区块头的映射）
3. handleNumberAndHashToBodyKey(HeightNumber, hash) -> Body{txs, Withdrawals, Uncles[]}（区块高度和区块hash组成的key和 区块体的映射）

并将区块中所有收据存储为单个收据数组，用于在区块链重组期间重新安排丢弃的交易。经过以上流程，一个个区块被添加到区块链上，并存入LevelDB数据库中，形成以太坊的这条区块链。



### 网络层

![image-20250728152610930](C:\Users\yt163\AppData\Roaming\Typora\typora-user-images\image-20250728152610930.png)

以太坊和BTC都是使用P2P网络架构，每个节点都是对等的，具有生成和验证新数据的能力。以太坊特别采用了Kademlia(Kad)协议来实现其P2P网络通信，确保了网络的分布式特性和高效数据转换。

#### Kademlia核心概念

KAD是一个基于Distributed Hash Table （DHT，分布式哈希表）的P2P网络协议。

##### 节点标识和键空间

节点ID：在Kademlia网络中，每个节点都有唯一一个节点ID，通过哈希函数生成。

键空间：节点ID和数据键都属于相同的键空间。键空间是一个由m位二进制数字构成的空间，常用长度160位。

##### 距离度量

异或距离：Kademlia采用异或算法测量两个节点之间的距离。

距离 = 节点ID₁ ⊕ 节点ID₂

- 这里的“⊕”（XOR）表示按位异或操作。
- 节点ID通常是一个大整数（如以太坊里通常为160位或256位的哈希值）。
- 距离本质上是这两个ID按二进制异或后所得整数的大小，越小代表越“近”。

##### 路由表

**基本思想**

- ##### 每个节点都维护一个“路由表”。

- 路由表不是简单地按物理邻近或时间排序，而是根据**与本节点ID的XOR距离**进行分区，这些分区叫做**桶（k-bucket）**。

- 每个bucket内存放若干（最多k个，k通常为16或20）与自己在该距离范围的其他节点的信息。

**桶的划分方式**

假设节点ID长度为`n`位二进制数（比如160位或256位），则每个节点将可能的节点空间划分为`n`个桶：

- 第i号桶：

  包含所有与自己ID前i位相同，第i+1位不同的节点。

  - 换句话说，第i号桶管理距离为`[2^i, 2^{i+1})`之间的节点

- **0号桶**：距离最大；几乎完全不同

- **(n-1)号桶**：距离最近，仅有最低一位不同

例如，160位ID，会有160个桶，每个桶里都是某个“距离段”上的节点。

##### kademlia操作

**节点查找**

发起节点根据路由表中记录的信息，选择距离目标ID最近的k个节点并向它们发出查询请求，这些节点将继续检查自己的路由表，进而查询目标距离还近的节点，直到找到目标节点或无法找到更近的节点为止。

**数据存储**

* 存储键生成：存储键通常由数据内容的哈希值生成，确保数据的唯一标识和检索。
* 存储操作：存储数据时，会选择距离存储键最近的k个节点，并将数据的副本存储在这些节点上。通过查找与数据键最近的k个节点，向他们发送存储请求。

**数据查找**

* 查找过程：与节点查找类似，基于数据键进行搜索，目标是找到实际存储该数据的节点。
* 查找操作：发起节点首先找到与数据键最近的k个节点，然后请求这些节点返回所需的数据或指向更近的目标数据节点信息。

具体步骤如下：

步骤一：从所有桶中收集候选节点

- 首先，将自己路由表中所有已知的节点（即所有bucket里的节点）**打散成一个列表**。
- 然后，对每个节点的ID计算：`distance = node.ID XOR targetKey`

步骤二：排序选最近的α或k个

- 将所有节点按`distance`从小到大排序。
- 取距离最小的前α（如3）或k（如16、20）个节点，作为初始查找候选。
- 后续收到的节点（如对方回复的节点列表）也按同样方式比对并补充到候选集中。

步骤三：递归推进

- 迭代地向这些“当前最靠近目标”的节点发起FIND_NODE/FIND_VALUE请求。
- 每收到一批更近的节点，就加入候选集合，**实时重新排序、去重**，继续推进直到找不到更近的。

**节点发现流程**

* 系统初始化：系统启动后，随机生成本地的NodeID，即LocalID，并在整个生命周期中保持不变。
* 连接公共节点：系统读取公共节点信息，通过PING和PONG命令验证节点活跃状态，验证通过后将公共节点信息写入本机的K桶。
* 定期刷新：每隔7200毫秒刷新一次K桶，保证网络状态。

具体步骤如下：

1）生成随机目标ID

- 每一轮，节点临时随机选取一个合法的 node ID 作为“查找目标”（不一定是真实存在的节点）。
- 这样可以随机地探索 Kademlia 距离空间的不同区域。

2）查找该随机ID最近的节点

- 用标准 Kademlia 查找流程，即“FINDNODE(target)”消息，不断向当前路由表中距离目标ID最近的节点递归查询，让他们返回自己所知道的更近的节点。
- 这一过程通常是并行完成的，以提高效率。

3）更新路由表

- 查找过程中遇到的活跃节点（无论其ID是否正好等于随机目标），都会被尝试加入/刷新到合适的bucket中。
- 如果目标ID附近的bucket不满，也能补充新的节点。

4）重复多次

- 以太坊实现里，会连续执行**8次随机目标ID查找**，即生成8个完全独立的随机目标ID，每次都做一次完整的Kademlia查找，这样基本能覆盖和刷新所有bucket。

5）效果

- 这样**不仅能发现邻近节点，还能冒险性地认识远处的节点**，提升整体连通性。
- 通过周期性运行这种机制，可以自愈网络、抵御部分节点失效带来的分区风险。



#### P2P节点通信

节点之间通过TCP和UDP协议来接受和发送数据，数据通常包含交易和区块。

**通信类型**

1. **广播新的交易对象：** 当节点接收到新的交易时，它会将交易广播给其邻居节点。
2. **广播新挖掘的区块：** 当节点挖掘出新的区块时，它会将新区块广播给其邻居节点。
3. **定期强制同步：** 节点会定期与邻居节点进行区块链的强制同步。每次同步时，节点会选择邻居节点中区块链总难度值最高的节点进行同步，以确保自身链的完整性和正确性。
4. **均匀同步新交易对象：** 将新出现的多个交易对象均匀地同步给邻居节点，确保网络中各节点数据的一致性和及时性。



### 共识层

以太坊1.0是POW算法，2.0逐步升级到POS。

#### 基于PoW的Ethash算法

**Ethash特性**

* **抗ASIC性：**旨在减少专用硬件(ASIC)的优势，使普通PC用户也能用CPU进行挖矿。
  * 内存限制：通过限制内存需求来抵制ASIC，因为ASIC矿机内存非常昂贵。
  * 随即内存读取：大量随机读取内存数据，使计算速度不仅取决于算力，还受内存读取速度的限制。

* **轻客户端可验证性：** 使轻客户端能够快速有效地校验区块。
* **完整区块链状态存储：** 矿工被要求存储完整的区块链状态。



#### POA权威证明算法 (proof of authority)

POA算法中，少数被授权的“专家”相互合作来打包区块并维护区块链，其他人无权打包区块。所以在一定程度上牺牲了去中心化特性，以换取系统的可控性和效率。

##### **Clique算法**

**背景：**

最初，以太坊的官方测试网络是“Morden”。然而，随着时间的推移，Morden 暴露出越来越多的遗留问题和兼容性问题，最终以太坊团队决定推倒重来，创建了新的测试网络“Ropsten”。与主网一样，Ropsten 最初使用的是 PoW 共识算法。

后来，Ropsten 遭到了恶意攻击，这主要是因为 PoW 共识算法的安全性依赖于计算机算力，而作为测试网络的 Ropsten 对算力的要求较低，导致攻击者能够轻易滥用算力。虽然可以通过重启测试网络来修复攻击造成的不良影响，但以太坊团队选择了一种更为彻底的解决方案：将共识算法改为 PoA 类型，这就是 Clique 模块的由来。

可以看出，Clique 在以太坊中仅用于测试网络，而真实的以太坊主网仍使用 PoW 算法（通过 ethash 模块实现）。不过，在创建私有网络时，用户可以自由选择使用 Clique 或 ethash。

###### **原理**

Clique通过预先设定好验证者节点进行区块验证和达成共识。

**1.验证者节点**

* 权威节点：Clique网络中的区块由一组预先设定好的权威节点(validators)创建和验证。这些节点身份是已知且可信的，通常由网络管理者决定。
* 有限数量的节点：验证者节点的数量是有限的，有助于提升效率。

**2.区块创建**

* 轮值机制：Clique使用轮值机制决定哪个验证者节点将创建下一个区块。
* 创建间隔：每个验证者在指定时间间隔内创建区块，一般为15秒左右。

**3.区块签名**

* 签名：验证者创建区块后，使用私钥对区块进行签名。其他节点可通过验证这个签名确认区块是合法的验证者创建的。
* 共识：如果有N个验证者，至少需要N/2+1个验证者的签名才能认为区块有效。

**4.容错机制**

* 双区块保护：为了防止恶意攻击和双花攻击，同一签名者在近似相邻高度（如连续或几乎连续的两个区块）不能连续出块。如果检测到同一权威节点在短时间内连续生成了两个高度的区块，这两个区块都会被认为“不完全合法”，无法同时被主链采纳。Clique 规定，每个签名者在最近N个区块内只能生产1个区块（N等于活跃签名者总数的一半，加1）。举例：假设有7个签名者，则N = floor(7/2)+1 = 4。也就是，任意4个连续区块里，同一个签名者只能签1个。
* 踢出机制：某个验证者行为不端或长时间不活跃，管理者可以踢出该验证者。



###### 工作流程

**1.区块生成**

* 每个验证者按顺序轮值生成区块
* 其他验证者收到区块后，验证签名并签署共识

**2.共识达成**

* 一个区块必须得到大多数验证者(N/2+1)的签名，才能被认为是有效的。
* 达成共识后，区块将被添加到区块链

**3.区块传播**

* 验证者将已签名的区块广播给网络中其他节点
* 其他节点收到区块后进行验证，并更新各自区块链副本。

**优点**

* 高效：只有少数共识者参与，能高效处理交易、生成区块。
* 低能耗：不需要像POW一样经过大量计算进行区块验证。
* 易于管理：验证者身份都是已知的。

**缺点**

* 中心化风险：违背了去中心化的理念，所以主要适用于联盟链和私链。



##### POS 算法

以太坊2.0采用的是基于PoS的Casper共识算法。

###### Casper算法

目前为止，以太坊生态系统中有两个版本的Casper：Casper CBC(Correct-by-Construction) 和 Casper FFG(Friendly Finality Gadget)。

* Casper CBC：最初由以太坊基金会研究员 Vlad Zamfir 提出。尽管研究最初集中在公链的 PoS 协议，但它已经扩展为一个更广泛的研究领域，包括一系列 PoS 模型。
* Casper FFG：由以太坊联合创始人 Vitalik Buterin 主导研究。最初的提议包括混合 PoW 和 PoS 系统，但实施仍在讨论中，新提案最终可能会完全转向仅使用 PoS 模型。

以太坊2.0使用的是**Casper FFG共识算法。**它采用的是 LMD-GHOST 分叉选择规则，LMD GHOST 同时也是 CBC 选择的分叉选择规则。

**算法大致过程**

* 1.验证者抵押ETH成为节点：
  * 用户将一定数量eth抵押进合约，成为验证者。
  * 验证者根据权益数量，被随机分配到出块、投票等责任。
* 2.区块生成与提议
  * 区块提议者：网络中某些验证者被选为proposer，负责构建新区块并广播
  * 区块链同步：新区块广播到全网，其他验证者下载、校验。
* 验证者投票(Attestation)
  * 验证者对新区块进行投票，这叫见证 或者 证实 区块有效性。
  * 投票包含对某一“源区块”(source checkpoint)和”目标区块”(target checkpoint)的签名，作为最终性判定的依据。

* Finality(终结性)判定
  * 若有2/3以上有效权益投票支持某个区块(即checkpoint)，该区块被视为Justified。
  * 如果后续另一个区块以该区块为父区块，也达到2/3投票，该区块和前一区块共同编为Finalized，不可逆转。

* 惩罚与激励
  * 正确参与提议和投票的验证者获得奖励。
  * 恶意或长期离线的验证者会被削减部分(slashing)或全部抵押ETH

**关键点细节说明**

**a. Slot & Epoch**

- **时间被分为Slot（时隙）和Epoch（纪元）**，如每12秒一个slot，32个slot为一个epoch。
- 每个slot会有一个区块提议者，其他验证者参与投票。

**b. Justification & Finalization（依据与终结）**

- Checkpoint区块如果获得2/3权益投票，则“justified”（有依据）。
- 下一个checkpoint再次获得2/3投票，则上一个和本次checkpoint都被“finalized”（终结），后面即使分叉也不可逆转。

**c. LMD GHOST（分叉选择规则）**

- 节点总是遵循“得票最多的链”（即汇总所有活跃验证者最新投票，分叉上票最多者为主链），保证链一致。

**d. 惩罚（Slashing）**

- 如果验证者作恶（如“双重投票”），会被削减权益并逐出网络，保证安全性。



### 激励层

以太坊有四种发行机制：初始发行、普通区块奖励、uncle区块奖励和uncle区块引用奖励。

* 初始发行：以太币在初始发行时，价格锚定比特币，以 1 BTC = 1337~2000 ETH 的价格进行发售。2014 年 7 月至 8 月期间，通过众筹发行了约 7200 万以太币，这些以太币全部发往众筹投资人的以太坊账户地址中。

* 普通区块奖励：给挖出区块的矿工的

  * 固定3ETH(拜占庭分叉后，从5ETH降为3ETH)
  * 区块内所有交易的交易费。
  * 如果普通区块引用了Uncle区块，每引用一个可以固定获得3ETH的1/32，最多只能引用2个。

* uncle区块奖励：给挖出此uncle区块矿工的奖励。 (uncle区块高度 + 8 - 引用uncle区块的普通区块高度) * 普通区块的固定奖励 / 8

* uncle区块被引用奖励：间隔层数指的是被引用的 uncle 区块与普通区块之间的高度差

  ![image-20250729150816642](C:\Users\yt163\AppData\Roaming\Typora\typora-user-images\image-20250729150816642.png)



### 合约层

以太坊作为一个应用开发平台，能够实现各种丰富的功能，得益于智能合约的存在。智能合约层是一个承上启下的层级，运行在底层基础设施之上，并为应用层提供各类功能接口。智能合约可以看作是将现实中的合约条款用代码形式描述，并记录到区块链中，然后由以太坊虚拟机（EVM）自动执行条款。智能合约从创建到执行需要以下几个步骤：

1. 编写合约：使用智能合约语言（如 Solidity）编写合约逻辑。
2. 编译合约：使用编译器编译合约，生成 ABI 接口和字节码。
3. 部署合约：使用合约部署工具将合约部署到以太坊网络上。
4. 执行合约：合约代码被载入 EVM 中，解释为机器语言并执行，执行完后会改变相应账户的状态。
5. 调用合约：使用合约交互平台调用合约功能，由 EVM 负责执行。
6. 销毁合约：调用合约的自毁函数，清空该合约账户的状态。

通过以上步骤，智能合约实现了从编写到部署、执行再到销毁的完整生命周期，为以太坊平台上的应用提供了强大的支持。

#### 合约创建

一笔交易的to字段为空时，表明是一个合约创建交易，交易的data字段保安和你了合约代码的字节码。创建步骤如下：

* 1.编写合约代码：以太坊主要合约语言有Solidity、Vyper、Serpent和LLL，Solidity最常用，
* 2.编译合约代码：使用编译器将代码编译成字节码，并生成ABI接口。
* 3.创建交易：将编译后的字节码附在交易的data字段，并将to字段置空。
* 4.提交交易：将交易提交以太坊网络，由EVM读取并执行。

#### 合约执行

执行前，EVM会判断合约是否为预编译合约，如果不是则交给编译器解析成机器码后在执行。

#### 合约调用

分为合约调用函数、合约调用合约。

**合约调用函数：**

和调用合约函数时，合约字节码会携带一个Input参数进入EVM解释器，其包含两部分：前4字节时函数签名的Keccak哈希值的前4字节，作为函数的唯一标志，解释器通过这4字节知道调用哪个函数。后面是该函数需要的参数，长度不定。

调用流程：

* 1.解析函数签名：通过CALLDATALOAD指令将前4字节入栈。
* 2.匹配函数：将这4字节依次与合约中的函数签名进行对比，匹配到的函数被调用。
* 3.执行函数：通过JUMPI指令跳转到匹配的函数代码，继续执行。后续的字节作为参数传递给函数

**合约调用合约**

有四种调用方式：CALL、CALLCODE、DELEGATECALL、STATICALL。STATICALL 表示不允许读取和修改状态变量的调用类型，暂未使用。其余三种如下：

| 调用方式               | 被修改状态的合约 | msg.sender     |
| ---------------------- | ---------------- | -------------- |
| CALL                   | 被调用的合约     | 被调用的合约   |
| CALLCODE（不建议使用） | 发起调用的合约   | 被调用的合约   |
| DELEGATECALL           | 发起调用的合约   | 发起调用的合约 |

DELEGATECALL是CALLCODE的升级版本，目的是使合约在不传输自身状态情况下，能够使用其他合约代码，这使得合约可以实现“库”的功能，可将可复用的代码放在一个合约中。当其他合约委托调用时，只是用库的代码而不会更改库中变量的状态。

通过CALL调用其他合约的流程：

​	1.准备调用参数：调用者将参数存储在内存中，然后执行CALL指令

​	2.执行CALL指令：CALL指令执行时创建一个新的合约对象，并将内存中的调用参数作为输入。

​	3.创建执行环境：解释器为新合约的执行创建新的栈和内存空间，不会破坏原合约的执行环境。

​	4.返回结果：通过RETURN指令将执行结果写入原合约指定的内存地址，原合约继续执行。



#### Gas和Gas优化

合约的部署和调用都会消耗一定的Gas数量，作为矿工提供计算和存储资源的报酬，也可防止以太坊网络遭到Dos攻击。

由于交易可以通过 Input Data 字段携带合约相关的字节码数据以实现部署合约或调用合约函数的目的，而这些字节码数据的计算、带宽和存储会消耗节点资源，因此用户还需要根据所使用的资源量进行付费。这确保了以太坊网络的资源得到合理分配和使用。

**计价规则**

1.先扣费，后执行：每个操作码在执行前先扣费，在执行。因为部分操作的Gas消耗无法提前得知，因此判断粒度时操作码而不是整个合约。

2.提前中止不退费：用过用户预设的Gas数量不足以支付操作码执行所需费用，合约执行中止，且不会退还已扣除的Gas。

3.释放资源可退费：如果某些操作码释放了存储资源，例如重置某个状态变量或销毁合约，则会在本次调用结束后退还部分Gas，但不得超过已使用Gas的一半。

**GasLimit、GasPrice和GasUsed**

GasLimit：发起交易时设置，表示本次交易可消耗的最大Gas数量

GasPrice（或GasFees）：发起交易时设置，表示本次交易每单位Gas价格，计价单位是ETH。合约Gas常用更小的计价单位Gwei，1ETH = 10^9 Gwei。

GasUsed：实际消耗的Gas数量，不超过GasLimit。

**BaseFees和PriorityFees**

2021 年 8 月 5 日，以太坊完成了伦敦升级，改进的 EIP-1559 用两个新参数（BaseFees 和 PriorityFees）替换了旧的 GasPrice 参数：

* BaseFees：以太坊上发送交易或完成操作所需的最低Gas价格。由协议动态调整，并且这些基本费会被销毁，不会支付给矿工。
* PriorityFees(Tip)：优先级费用或消费，用户支付给矿工的消费，以便矿工优先处理自己的交易或操作。可以用户自行设置，默认情况为2Gwei。
* MaxFees：前两者之和，相当于之前的GasPrice，但增加了一个“最高”定语，实际用到的小费可能达不到预设的PriorityFees这么高，多余的会退还。



### 应用层

是区块链的展示层和业务成，通过调用web3等接口，使得各类应用与区块链集成。

包含两类应用：

​	1.工具类：本身并不使用区块链技术，只是调用了区块链接口，为用户提供图形化界面，例如：

* 轻节点钱包：提供用户友好的界面来管理钱包和进行交易。
* 区块链浏览器：用于查看区块、交易和账户信息。
* 中心化交易所：通过区块链接口实现交易，但本身是中心化的。

​    2.区块链技术应用：以太坊中称为DApps 去中心化应用，全部功能或部分功能由区块链技术实现，真正发挥区块链的优势，如：

* 去中心化金融(DeFi)应用：去中心化交易所 DEX、借贷平台等。
* 去中心化自治组织DAO：通过智能合约实现的自治组织。
* 游戏和娱乐应用：如区块链游戏、数字收藏品等。

#### 钱包

这里是狭义的钱包概念，用于管理密钥的系统。

钱包只包含密钥，通过密钥来控制以太坊区块链中的代币。用户通过钱包密钥来签署交易，以证明他们拥有代币，从而控制以太坊网络上的代币。因此，钱包可以看作是一个包含公私钥的钥匙串。

以太坊客户端实现了软件钱包和硬件钱包。软件钱包又分为：非确定性钱包和确定性钱包。

* 非确定性钱包：其中每个密钥都是随机生成的，密钥之间没有关系。
* 确定性钱包：所有密钥都来一个叫种子seed的主密钥，其中包含的所有密钥都是互相关联的。只要主密钥还在，就可以重新生成其它子密钥。

在确定性钱包中使用了许多不同的密钥派生方法，常用的是树状结构，由此生成的钱包称为分层确定性钱包或 HD 钱包。为了使种子更容易被记住，通常将其编码为一些英文单词，也叫做**助记词。**



#### DApp

基于开放的、去中心化的P2P基础架构服务的web应用程序。可以是一个网站或者一个手机应用，主要包含智能合约和web用户界面，就可以称为一个DApp。

**优势**

DApp比智能合约更能体现以太坊作为通用区块链平台的功能。每一个DApp都运行在以太坊的节点网络上，有2以下优点：

* 永不宕机：依赖区块链系统运行，不会因为单点故障而停机。
* 去中心化：DApp数据分布式存储在区块链所有节点上，避免数据集中化。
* 公开透明：DApp代码是开源的，由所有人或组织共同维护监督，修改代码需要大多数用户达成共识，不能由单个人或机构私自修改。
* 激励机制：为了维持DApp长久运行，需要设计激励机制来奖励消耗算力、内存空间等资源的用户，确保DApp在各个用户节点正常运行。

**架构**

DApp架构通常分为三种：

* 间接模式：Web网页客户端与中间服务器交互，中间服务器再与区块链交互。
* 混合模式：链上数据直接与区块链交互，其他内容与中间服务器交互。
* 直接模式：DApp直接与区块链交互。

DApp 的实现与传统 Web App 对比如下表：

| 类别     | Web App                         | DApp                                        |
| -------- | ------------------------------- | ------------------------------------------- |
| 前端     | html、css、JavaScript           | 与 webApp 一致                              |
| 后端     | Java 等高级语言编写，中心化部署 | Solidity 等合约专用语言编写，部署在区块链上 |
| 数据存储 | 存储在中心化数据库上            | 存储在以太坊区块链上                        |
| 使用货币 | 法币                            | 运行在区块链之上的代币                      |

传统 Web App 的技术架构称为 Web 2.0，而 DApp 架构称为 Web 3.0。Web 3.0 与 Web 2.0 是完全不同的体系架构。区块链技术，尤其是以太坊的出现，使 Web 3.0 成为基于区块链进行价值传递的基础网络。

在设计理念和哲学上，Web 3.0 带来了自由、平等和去中心化。用户可以自己治理和使用数据，不再依赖中心化服务器，从而避免数据被滥用，最大限度地保护隐私。这也杜绝了 Web 2.0 时代屡见不鲜的数据大规模泄露事件。

通过 Web 3.0，用户能够真正掌控自己的数据，实现数据的私密性和安全性，推动了互联网向更加透明和公平的方向发展。

Web3.0 架构图如下：![image-20250729162450829](C:\Users\yt163\AppData\Roaming\Typora\typora-user-images\image-20250729162450829.png)

从技术架构来看，Web 3.0 更加复杂，它在传统信息互联网的基础上增加了价值的传递。Web 3.0 引入 Web3.js，通过远程过程调用（RPC）从远程计算机上请求服务器来与区块链节点通信，并且需要借助钱包来连接前端的 DApp 和底层区块链，从而实现信息和价值在整个网络中的传递。

从整个流程来看，底层逻辑很复杂，但对于普通用户来说，使用 DApp 浏览器访问 DApp 的方式与传统 App 无差别。用户接触的仍然是熟悉的前端页面。

可以说，DApp 浏览器是连接用户与 Web 3.0 世界的窗口，为用户提供端对端、匿名、安全和零信任的交互体验。

从技术架构来看，Web 3.0 更加复杂，它在传统信息互联网的基础上增加了价值的传递。Web 3.0 引入 Web3.js，通过远程过程调用（RPC）从远程计算机上请求服务器来与区块链节点通信，并且需要借助钱包来连接前端的 DApp 和底层区块链，从而实现信息和价值在整个网络中的传递。

从整个流程来看，底层逻辑很复杂，但对于普通用户来说，使用 DApp 浏览器访问 DApp 的方式与传统 App 无差别。用户接触的仍然是熟悉的前端页面。

可以说，DApp 浏览器是连接用户与 Web 3.0 世界的窗口，为用户提供端对端、匿名、安全和零信任的交互体验。

**DApp浏览器**

目前绝大多数 DApp 仅支持 Web 端使用，这增加了用户的使用成本，不利于 DApp 的普及。在这种背景下，移动端的 DApp 浏览器应运而生。与传统浏览器不同，DApp 浏览器并不是一个独立入口，它需要结合或内嵌在数字钱包中才能使用。因为区块链带来的是价值互联网，现阶段的价值需要借助钱包来传递，钱包也是加密货币持有者的标配，借助钱包的流量入口优势，DApp 更容易触达用户。

常见的 DApp 浏览器包括 Mist、MetaMask、Coinbase Wallet、Trust Wallet、imToken、Status 和 Cipher 等。以太坊的 Mist 是最早的 DApp 浏览器，兼具钱包和 DApp 入口的功能，用户可以通过 Mist 与以太坊网络上的其他 DApp 交互。但 Mist 需要用户下载以太坊完整区块链数据才能运行。由于账本会随着时间越来越庞大，同步一个全节点数据需要非常长的时间和较大硬盘容量，这对普通用户非常不友好。

因此，后来出现的 DApp 浏览器一般通过 RPC 访问全节点来与区块链交互，无需自身作为全节点运行，这大大简化了用户的使用过程，提高了 DApp 的普及率和可用性。
